<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Affordance Level Annotation</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'secondary': '#6366f1',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for video element and responsiveness */
        .video-card {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .video-player {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 p-4 sm:p-8">

    <!-- Header and Controls -->
    <header class="max-w-4xl mx-auto mb-8 bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-primary mb-2">Affordance Level Annotation</h1>
        <p class="text-gray-600 mb-4">Review each video clip, check the model's prediction, and classify the affordance level as 'Telec' or 'Gibsonia'. Your selections are saved automatically in your browser.</p>

        <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
            <div id="status-message" class="text-sm font-medium text-gray-500">
                Loading data...
            </div>
            <button id="download-btn" class="flex items-center space-x-2 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-[1.02] disabled:opacity-50" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l1.293-1.293a1 1 0 111.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z" clip-rule="evenodd" />
                    <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v7a1 1 0 11-2 0V3a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
                Download Annotations (.csv)
            </button>
        </div>
    </header>

    <!-- Main Content Area (where the video cards are rendered) -->
    <main id="video-list" class="max-w-4xl mx-auto grid grid-cols-1 gap-6">
        <!-- Video cards will be dynamically inserted here -->
    </main>

    <script>
        // --- Configuration ---
        const DATA_URL = './data.csv'; 
        const VIDEO_BASE_PATH = './videos/'; 
        const LOCAL_STORAGE_KEY = 'affordance_annotations';
        const VIDEO_LIST_EL = document.getElementById('video-list');
        const DOWNLOAD_BTN = document.getElementById('download-btn');
        const STATUS_EL = document.getElementById('status-message');

        // Global data store
        let allVideoData = [];

        // Classification options for the dropdown
        const options = [
            { value: '', label: '— Select Level —' },
            { value: 'Telec', label: 'Telec' },
            { value: 'Gibsonia', label: 'Gibsonia' },
        ];

        // --- Core Functions ---

        /**
         * Parses a CSV string into an array of objects.
         */
        function parseCSV(csvString) {
            const lines = csvString.trim().split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) return []; 
            
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();

                // Find the index of the first comma (video_path, model_response)
                const firstCommaIndex = line.indexOf(',');

                // Find the index of the last comma (model_response, label)
                const lastCommaIndex = line.lastIndexOf(',');
                
                if (firstCommaIndex === -1 || lastCommaIndex === -1 || lastCommaIndex === firstCommaIndex) {
                    console.warn("Skipping malformed CSV line:", line);
                    continue; 
                }
                
                // 1. video_path
                const video_path = line.substring(0, firstCommaIndex).trim();

                // 3. label
                const label = line.substring(lastCommaIndex + 1).trim().replace(/"/g, '');

                // 2. model_response (Handles quoted text)
                let model_response = line.substring(firstCommaIndex + 1, lastCommaIndex).trim();
                if (model_response.startsWith('"') && model_response.endsWith('"')) {
                     model_response = model_response.substring(1, model_response.length - 1).replace(/""/g, '"');
                } else {
                     model_response = model_response.replace(/^"|"$/g, '').replace(/""/g, '"');
                }

                data.push({
                    video_name: video_path, 
                    model_response: model_response,
                    level: label
                });
            }

            return data;
        }

        /**
         * Reads the annotation state from localStorage and merges it with the fresh data.
         */
        function loadSavedSelections() {
            try {
                const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                return storedData ? JSON.parse(storedData) : {};
            } catch (e) {
                console.error("Could not load from localStorage:", e);
                return {};
            }
        }

        /**
         * Saves the current classification state to localStorage.
         */
        function saveSelections() {
            const currentSelections = {};
            allVideoData.forEach(item => {
                currentSelections[item.video_name] = item.level || '';
            });
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(currentSelections));
            } catch (e) {
                console.error("Could not save to localStorage:", e);
            }
        }

        /**
         * Handles the change event from a classification dropdown.
         */
        function handleSelectionChange(index, value) {
            if (index >= 0 && index < allVideoData.length) {
                allVideoData[index].level = value;
                saveSelections();
                updateStatus();
            }
        }

        /**
         * Updates the status message based on completion progress.
         */
        function updateStatus() {
            const total = allVideoData.length;
            const completed = allVideoData.filter(item => item.level && item.level !== '').length;
            
            STATUS_EL.textContent = `Progress: ${completed} of ${total} clips classified (${Math.round((completed / total) * 100) || 0}%)`;
            
            DOWNLOAD_BTN.disabled = total === 0;

            const percent = Math.round((completed / total) * 100) || 0;
            STATUS_EL.classList.remove('text-red-500', 'text-yellow-600', 'text-green-600', 'font-bold');
            if (percent === 100) {
                STATUS_EL.classList.add('text-green-600', 'font-bold');
            } else if (percent > 0) {
                STATUS_EL.classList.add('text-yellow-600');
            } else {
                STATUS_EL.classList.add('text-gray-500');
            }
        }


        /**
         * Creates a single HTML card for a video entry.
         */
        function createVideoCard(item, index) {
            const videoSrc = `${VIDEO_BASE_PATH}${item.video_name}`;
            const currentLevel = item.level || '';
            
            const optionsHtml = options.map(opt => `
                <option value="${opt.value}" ${opt.value === currentLevel ? 'selected' : ''}>
                    ${opt.label}
                </option>
            `).join('');

            const selectId = `level-select-${index}`;
            const videoId = `video-player-${index}`; // Add unique ID for programmatic access

            return `
                <div class="video-card bg-white p-6 rounded-xl shadow-md border border-gray-100 transition duration-300 hover:shadow-xl">
                    <h2 class="text-xl font-semibold text-secondary truncate">Clip ${index + 1}: ${item.video_name}</h2>
                    
                    <!-- Video Player: Uses preload="auto", autoplay, and loop for reliability -->
                    <video id="${videoId}" class="video-player" controls preload="auto" muted autoplay loop>
                        <!-- Primary source with explicit type -->
                        <source src="${videoSrc}" type="video/mp4" onerror="this.parentNode.innerHTML='<div class=\\'p-4 bg-red-100 text-red-700 rounded-lg\\'>Error: Video file not found or failed to load. Check path: <strong>${videoSrc}</strong></div>'">
                        <!-- Secondary source for browser flexibility (no type specified) -->
                        <source src="${videoSrc}"> 
                        Your browser does not support the video tag.
                    </video>

                    <!-- Model Response -->
                    <div class="p-4 bg-gray-50 border-l-4 border-primary/50 rounded-lg">
                        <p class="text-sm font-medium text-primary mb-1">Model Response:</p>
                        <p class="text-sm text-gray-700">${item.model_response}</p>
                    </div>

                    <!-- Classification Dropdown -->
                    <div>
                        <label for="${selectId}" class="block text-sm font-medium text-gray-700 mb-1">Affordance Classification:</label>
                        <select id="${selectId}" data-index="${index}" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-secondary focus:border-secondary sm:text-sm rounded-md bg-gray-50 border transition duration-150 ease-in-out">
                            ${optionsHtml}
                        </select>
                    </div>
                </div>
            `;
        }

        /**
         * Renders all video cards and attaches event listeners.
         */
        function renderData() {
            VIDEO_LIST_EL.innerHTML = allVideoData.map(createVideoCard).join('');

            // Attach event listeners to all dynamically created dropdowns
            document.querySelectorAll('select[data-index]').forEach(selectEl => {
                selectEl.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.index, 10);
                    const value = e.target.value;
                    handleSelectionChange(index, value);
                });
            });

            // CRITICAL FIX: Force video loading after elements are in the DOM
            // This ensures the browser re-evaluates the video source and metadata.
            document.querySelectorAll('.video-player').forEach(videoEl => {
                // If the video's readyState is not HAVE_ENOUGH_DATA (4), force it to load.
                // We also check for muted state before trying to play to respect browser policy.
                if (videoEl.readyState < 4) {
                    try {
                        videoEl.load();
                        // Try to play immediately if muted, otherwise the user must interact.
                        if (videoEl.muted) {
                            videoEl.play().catch(e => console.log("Autoplay blocked/failed (muted try):", e));
                        }
                    } catch (e) {
                        console.error("Error calling load() or play() on video:", e);
                    }
                }
            });


            updateStatus();
        }

        /**
         * Converts the current data state to a CSV string.
         */
        function convertToCSV() {
            const headers = ['video_path', 'model_response', 'label'];
            let csvContent = headers.join(',') + '\n';

            allVideoData.forEach(item => {
                const modelResponse = `"${item.model_response.replace(/"/g, '""')}"`;
                const label = item.level || ''; 
                
                const row = [item.video_name, modelResponse, label];
                csvContent += row.join(',') + '\n';
            });
            return csvContent;
        }

        /**
         * Triggers the download of the CSV file.
         */
        function downloadCSV() {
            const csv = convertToCSV();
            const filename = `affordance_annotations_${new Date().toISOString().slice(0, 10)}.csv`;
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            
            const link = document.createElement("a");
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        /**
         * Main function to initialize the application.
         */
        async function initializeApp() {
            try {
                // 1. Fetch CSV data
                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`Failed to load data. Status: ${response.status}`);
                }
                const csvText = await response.text();
                
                // 2. Parse CSV into data objects
                const freshData = parseCSV(csvText);

                // 3. Load saved selections from browser storage
                const savedSelections = loadSavedSelections();

                // 4. Merge saved selections into the fresh data
                allVideoData = freshData.map(item => ({
                    ...item,
                    level: savedSelections[item.video_name] || item.level || '', 
                }));
                
                if (allVideoData.length === 0) {
                     throw new Error("No data records found after parsing CSV. Check CSV format.");
                }

                // 5. Render UI
                renderData();
                DOWNLOAD_BTN.addEventListener('click', downloadCSV);

            } catch (error) {
                console.error("Initialization failed:", error);
                VIDEO_LIST_EL.innerHTML = `<div class="p-6 bg-red-100 text-red-700 rounded-xl max-w-4xl mx-auto">
                    <h2 class="text-lg font-bold mb-2">Error Loading Data</h2>
                    <p>Could not load or parse the data file. Please ensure **data.csv** exists in this directory and is formatted correctly with the header: <code>video_path,model_response,label</code>.</p>
                    <p class="text-sm mt-2">Details: ${error.message}</p>
                </div>`;
                STATUS_EL.textContent = "Error: Data failed to load.";
                STATUS_EL.classList.add('text-red-500');
            }
        }

        // Start the application on load
        window.onload = initializeApp;

    </script>
</body>
</html>