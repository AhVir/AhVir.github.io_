<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tanvir Ahmed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: default;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
    </style>

    <script data-goatcounter="https://ahvir.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

    
    
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Background particles
        const bgParticles = [];
        const numBgParticles = 100;

        for (let i = 0; i < numBgParticles; i++) {
            bgParticles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 0.7,
                vy: (Math.random() - 0.5) * 0.7,
                size: Math.random() * 1.2 + 0.3,
                opacity: Math.random() * 0.5 + 0.3
            });
        }

        // Text settings
        const text = "Tanvir Ahmed";
        const fontSize = Math.min(canvas.width, canvas.height) * 0.15;
        ctx.font = `bold ${fontSize}px Arial`;
        const textWidth = ctx.measureText(text).width;
        const textX = (canvas.width - textWidth) / 2;
        const textY = canvas.height / 2 + fontSize / 3;

        // Particle setup
        const particles = [];
        const particleDensity = 3;
        let isHovered = false;
        let hoverX = 0, hoverY = 0;
        let mouseForce = 0;
        let mouseVelocityX = 0, mouseVelocityY = 0;
        let lastMouseX = 0, lastMouseY = 0;

        ctx.fillStyle = '#fff';
        ctx.fillText(text, textX, textY);
        const textData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < canvas.height; y += particleDensity) {
            for (let x = 0; x < canvas.width; x += particleDensity) {
                const alpha = textData[(y * canvas.width + x) * 4 + 3];
                if (alpha > 128) {
                    const hueBase = Math.random() * 60 + 180;
                    const hueVariation = Math.random() * 40 - 20;
                    particles.push({
                        x: x,
                        y: y,
                        originX: x,
                        originY: y,
                        vx: 0,
                        vy: 0,
                        size: Math.random() * 1.5 + 1,
                        color: `hsl(${hueBase + hueVariation}, 80%, ${Math.random() * 20 + 60}%)`,
                        angle: Math.random() * Math.PI * 2,
                        speed: Math.random() * 0.2 + 0.1,
                        freq: Math.random() * 0.2 + 0.05,
                        life: Math.random(),
                        lifeSpeed: Math.random() * 0.01 + 0.005,
                        noiseOffset: Math.random() * 100
                    });
                }
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            mouseVelocityX = currentX - lastMouseX;
            mouseVelocityY = currentY - lastMouseY;
            lastMouseX = currentX;
            lastMouseY = currentY;
            hoverX = currentX;
            hoverY = currentY;

            const textAreaPadding = 100;
            const textLeft = textX - textAreaPadding;
            const textRight = textX + textWidth + textAreaPadding;
            const textTop = textY - fontSize - textAreaPadding;
            const textBottom = textY + textAreaPadding;
            const wasHovered = isHovered;
            isHovered = (
                hoverX > textLeft &&
                hoverX < textRight &&
                hoverY > textTop &&
                hoverY < textBottom
            );
            if (isHovered && !wasHovered) {
                mouseForce = 0;
                const rampUp = () => {
                    mouseForce = Math.min(1, mouseForce + 0.05);
                    if (mouseForce < 1 && isHovered) requestAnimationFrame(rampUp);
                };
                rampUp();
            } else if (!isHovered && wasHovered) {
                const rampDown = () => {
                    mouseForce = Math.max(0, mouseForce - 0.02);
                    if (mouseForce > 0 && !isHovered) requestAnimationFrame(rampDown);
                    else mouseForce = 0;
                };
                rampDown();
            }
        });

        canvas.addEventListener('mouseout', () => {
            isHovered = false;
            mouseForce = 0;
            mouseVelocityX = 0;
            mouseVelocityY = 0;
        });

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Draw and animate background particles ---
            for (let i = 0; i < bgParticles.length; i++) {
                const p = bgParticles[i];
                p.x += p.vx;
                p.y += p.vy;

                // Wrap around screen edges
                if (p.x < 0) p.x = canvas.width;
                if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height;
                if (p.y > canvas.height) p.y = 0;

                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw lines between close background particles
            for (let i = 0; i < bgParticles.length; i++) {
                for (let j = i + 1; j < bgParticles.length; j++) {
                    const p1 = bgParticles[i];
                    const p2 = bgParticles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 100) {
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 - dist / 500})`;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }

            // --- Animate text particles ---
            const time = Date.now() * 0.001;
            particles.forEach(p => {
                p.life += p.lifeSpeed;
                if (p.life > 1) p.life = 0;

                const dx = hoverX - p.x;
                const dy = hoverY - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (isHovered && mouseForce > 0) {
                    const influence = 200 / (distance + 40) * mouseForce;
                    if (influence > 0.1) {
                        let angle = Math.atan2(dy, dx) + Math.PI;
                        const mouseSpeed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);
                        const mouseAngle = Math.atan2(mouseVelocityY, mouseVelocityX);
                        const noiseValue = Math.sin(time * 0.5 + p.noiseOffset) * 0.5;
                        angle += noiseValue * 0.5 + (mouseSpeed * 0.01 * Math.sin(mouseAngle));
                        const force = influence * (12 + mouseSpeed * 0.2);
                        p.vx += Math.cos(angle) * force;
                        p.vy += Math.sin(angle) * force;
                        const turbulence = 0.3 + Math.min(1, mouseSpeed * 0.05);
                        p.vx += (Math.random() - 0.5) * influence * 3 * turbulence;
                        p.vy += (Math.random() - 0.5) * influence * 3 * turbulence;
                    }
                }

                const spring = 0.08;
                const friction = 0.9;
                const wobbleX = Math.sin(time * 0.7 + p.noiseOffset) * 0.2;
                const wobbleY = Math.cos(time * 0.6 + p.noiseOffset * 1.3) * 0.2;
                p.vx += (p.originX - p.x + wobbleX) * spring;
                p.vy += (p.originY - p.y + wobbleY) * spring;
                p.vx *= friction;
                p.vy *= friction;

                p.angle += p.freq;
                const idleStrength = 0.6 - (mouseForce * 0.3);
                p.vx += Math.cos(p.angle) * p.speed * idleStrength;
                p.vy += Math.sin(p.angle) * p.speed * idleStrength;
                p.x += p.vx;
                p.y += p.vy;

                const speed = Math.min(1, Math.sqrt(p.vx * p.vx + p.vy * p.vy) * 2);
                const pulse = Math.sin(p.life * Math.PI * 2) * 10;
                const hueShift = speed * 20;
                const brightness = 60 + speed * 20 + pulse;
                ctx.fillStyle = `hsl(${parseInt(p.color.split('(')[1].split(',')[0]) + hueShift}, 85%, ${brightness}%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * (1 + speed * 0.5), 0, Math.PI * 2);
                ctx.fill();
            });

            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>

    <div id="view-counter">Loading views...</div>
    <script>
      fetch('https://weathered-wood-1a35.abcdeeddcba.workers.dev/count')
        .then(response => response.json())
        .then(data => {
          document.getElementById('view-counter').textContent = `Views: ${data.views}`;
        });
    </script>
    
</body>
</html>
